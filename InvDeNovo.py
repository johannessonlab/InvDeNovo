#!/usr/bin/env python

# InvDeNovo.py
# Version 0.2
# Author: Jesper Svedberg, Department of Organismal Biology, Uppsala University
# E-mail: jesper.svedberg@ebc.uu.se
#
# InvDeNovo.py tries to identify inversions in fragmented denovo assembles. It does this by
# looking for inversion breakpoints in a MUMmer alignment coordinate file. The script looks
# for a pairs of contigs that a) both align next to each other at two different locations on
# a chromosome and b) have both changed alignment direction at both locations. In other words
# it looks for the alignment pattern contig_1,contig_2,...,-contig_1,-contig_2. This is the
# signature of an inversion in the fragmented denovo assembly.
# The workflow is the following: Align the fragmented denovo assembly against a high quality
# reference assembly using the nucmer tool in the MUMmer package. Convert the delta file to
# a coordinate file in the BTAB format using "show-coords -Br file.delta > file.btab".
#
# Usage: InvDeNovo.py -c target_chromosomes [-s score_cutoff -g allowed_gaps] file.btab
#
# Usage of default values of -s and -g is recommended. The script can only search for one
# chromosome (ie one contig in the reference genome) at one time.
# InvDeNovo.py outputs results to the terminal.
#
# The score cutoff function is semi-depricated. The primary problem when identifying inversions
# is spurious alignment of repetitive sequences. Initially filtering of hits was primarily done
# using this parameter, but I later added a filtering of the alignments generated by MUMmer, in
# order to remove such spurious alignments, and that strategy worked much better. Hit scores are
# still reported in the output, but it's not very informative using my datasets. Filtering using
# this parameters may still be useful for other datasets though.
#
# The gaps allowed parameter controls the number of contigs between a contig pair. Again this was
# primarily used to deal with spurious alignment of repetitive sequences and may not be very
# useful. Lowering it to 0 will give the most stringent selection of hits.
#
# Output: btab_filename    chromosome    contig1:contig2    gap_length    coord_breakpoint1    coord_breakpoint2
#
# If contig1 = -contig2, both breakpoints are located within one contig.

import sys
import csv
from operator import itemgetter
import argparse
#import time

# Converts entries in a table from strings to whatever format that is specified in the type list,
# for instance integers or floats. The type list is now formatted for the MUMmer show-coords
# btab format.
def tableTypeConvert(table, typeList):
    outTable = []
    for line in table:
        newLine = []
        i = 0
        for entry in line:
            if typeList[i] == "S":
                newLine.append(entry)
            elif typeList[i] == "I":
                newLine.append(int(entry))
            elif typeList[i] == "F":
                newLine.append(float(entry))
            i += 1
        
        outTable.append(newLine)
        
    return outTable

# Sorts a table in list or tuple form after several columns in reversed order
def sortTable(table, columns):
    for col in columns:
        table = sorted(table, key=itemgetter(col))
    return table

# Returns column from matrix
def getColumn(matrix,i):
    f = itemgetter(i)
    return map(f,matrix)

# Concatenates a list
def catWords(wordlist, separator=", "):
    return separator.join(wordlist)

# Not used
# Generates the inverted pairs of names. Ie "-contig1:contig2" -> "contig1:-contig2"
def reversePair(pairString, sep=":"):
    plist = pairString.split(sep)
    
    for p in plist:
        if p[0] == "-":
            p = p[1:]
        else:
            p = "-" + p
    
    return plist[1] + sep + plist[0]

# Generates the inverted pairs of names. Ie "-contig1:contig2" -> "contig1:-contig2"
def inversePair(pairString, sep=":"):
    plist = pairString.split(sep)
    olist = []
    
    for p in plist:
        if p[0] == "-":
            p = p[1:]
        else:
            p = "-" + p
        olist.append(p)
    
    return olist[0] + sep + olist[1]

# Generates alignment environment score
def scoreEnv(first, second, table, internal=False):
    score = 0
    out = str(first)

    scomp = -1
    dcomp = 2
    if internal:
        scomp = 1
        dcomp = 0
 
    if table[first-1][0] == table[second][0]:
        score += scomp
        out += "A "
    
    if second >= LEN_TABLE-1:
        return SCALE_ENV * score
    
    if table[first][0] == table[second+1][0]:
        score += scomp
        out += "B "
    
    if table[first-1][0] == table[second+1][0]:
        score += scomp
        out += "C "
    
    if (table[first-1][0] == table[first][0]) and (table[second][0] == table[second+1][0]):
        score += dcomp
        out += "D "
    
    #print out
    return SCALE_ENV * score

# Generates alignment length score
def scoreLength(alignLen, cutoff=1000, scale=1000):
    if alignLen > 5000:
        out = 2
    elif alignLen > 1000:
        out = 1
    elif alignLen > 500:
        out = 0
    else:
        out = -2
    return SCALE_LEN * out
    #return SCALE_LEN * ((alignLen - cutoff) / float(scale))

# Alignment identity score
def scorePercent(row):
    percent = abs(row[6] - row[7]) / float(row[2])
    return SCALE_PERC * percent

# Breakpoint gap score
def scoreGap(gap):
    return SCALE_GAP * gap


# Generates a dictionary of alignment pairs
def createPairDict(pairDict, table, maxLines, pairJump):

    rightmost = 0

    for i in range(maxLines):
        if table[i][17] == "Minus":
            fpname = "-" + table[i][0]
        else:
            fpname = table[i][0]
            
        if table[i+pairJump][17] == "Minus":
            lpname = "-" + table[i+pairJump][0]
        else:
            lpname = table[i+pairJump][0]
        
        if table[i][5] != table[i+pairJump][5]:
            rightmost = 0
            continue
           
        if fpname == lpname:
            continue

        isInternal = False
        if fpname.replace("-","") == lpname.replace("-",""):
            if ALLOW_INTERNAL:
                isInternal = True
            else:
                continue

        if table[i][9] > rightmost:
            rightmost = table[i][9]
        
        if table[i][-1] == "overlapped" or table[i+pairJump][-1] == "overlapped":
            continue

        if table[i+pairJump][9] < rightmost:
            table[i+pairJump].append("overlapped")
            #print lpname + " is overlapping. " + str(i+pairJump+1)
            continue
        else:
            overlap = getOverlap(i, i+pairJump, table)
            if overlap > OVERLAP_CUTOFF:
                #print lpname + " is overlapping with: " + str(overlap) + " " + str(i+pairJump+1)
                table[i+pairJump].append("overlapped")
                continue

        pairName = fpname + ":" + lpname
        pairStats = [i, pairJump-1, table[i][5], table[i][9], scoreEnv(i, i+pairJump, table, isInternal), scoreLength(table[i][12]), scoreLength(table[i+pairJump][12]), scorePercent(table[i]), scorePercent(table[i+pairJump]), scoreGap(pairJump-1)]
        pairStats.append(sum(pairStats[4:]))
        
        if pairName in pairDict:
            pairDict[pairName][1].append(pairStats)
        else:
            pairDict[pairName] = [True, [pairStats]]
    
    return pairDict

# Creates dictionary of all reference contigs with btab line numbers for each alignment
# in a list at each nucleotide position.
def alignCoverage(btab):
    contigDict = {}
    for i, row in enumerate(btab):
        if row[5] in contigDict:
            #print "   " + row[0]
            for j in xrange(row[8],row[9]):
                contigDict[row[5]][j].append(i)
        else:
            print row[5]
            cLen = int(row[18])
            #print cLen
            st=time.time()
            cgList = [[] for _ in xrange(cLen)]
            end=time.time()
            print end - st
            print sys.getsizeof(cgList)
            #print len(cgList)
            for j in xrange(row[8],row[9]):
                cgList[j].append(i)
            contigDict[row[5]] = cgList
    return contigDict

# Calculates average coverage for a portion of a reference contig (between start and
# stop.
def avgCoverage(contiglist, start, stop):
    alist = contiglist[start:stop]
    covSum = 0
    for pos in alist:
        covSum += len(pos)
    return covSum / float(len(alist))

def findMultiCoverage(contiglist, start, stop):
    alist = contiglist[start:stop]
    covSum = 0
    for pos in alist:
        if len(pos) > 1:
            covSum += 1
    return covSum / float(len(alist))

def findOverlap(btab, contig1, contig2, contiglist, start, stop):
    alist = contiglist[start:stop]
    covSum = 0
    for pos in alist:
        if len(pos) < 2:
            continue
        cList = getAlignedContigs(btab, pos)
        if contig1 == contig2:
            if cList.count(contig1) > 1:
                covSum += 1
        else:
            if (contig1 in cList) and (contig2 in cList):
                covSum += 1
    return covSum / float(len(alist))

def getAlignedContigs(btab, row_list):
    outlist = []
    for i in row_list:
        outlist.append(btab[i][0])
    return outlist

def isSameContig(btab, row1, row2):
    if btab[row1][0] == btab[row2][0]:
        return True
    else:
        return False

def printInvList(ll, btab, form="Normal"):
    if form == "xNormal":
        out = str(ll[0]) + "\t" + str(ll[1]) + "\t" + "\t".join([str(x) for x in ll[3:6]]) + "\t"+ "\t".join(["%.2f" % x for x in ll[7:]])
    elif form == "Normal":
        out = str(ll[6])
    return out
        
    

def isOverlapped(row1, row2, btab):
    a1 = btab[row1]
    a2 = btab[row2]
    
    if a1[2] < a2[2]:
        start = a1[8]
        stop = a1[9]
    else:
        start = a2[8]
        stop = a2[9]

    olapRatio = findOverlap(btab, a1[0], a2[0], alignDict[a1[5]], start, stop)

    if olapRatio > 0.1:    
        print a1[0] + ":" + a2[0] + " " + str(olapRatio)

    if olapRatio > OVERLAP_CUTOFF:
        return True
    else:
        return False
    
def getOverlap(row1, row2, btab):
    a1 = btab[row1]
    a2 = btab[row2]
    
    start = a2[8]
    stop = a2[9]

    coverage = 0

    if (a2[8] > a1[8]) and (a2[8] < a1[9]):
        #a1Len = a1[9]-a1[8]
        a2Len = a2[9]-a2[8]

        if (a1[9] > a2[9]):
            coverage = 1
        else:
            coverage = 1-((a2[9]-a1[9])/float(a2Len))

    return coverage


BTAB_TYPES = "SSISSSIIIIFFIIISISIIIS"
SCALE_ENV = 3.0
SCALE_LEN = 2.0
SCALE_PERC = 5.0
SCALE_GAP = -2.0

SCORE_CUTTOFF = 5
OVERLAP_CUTOFF = 0.5


parser = argparse.ArgumentParser(description='Identifies inversions in fragmented denovo assemblies by looking for TWO breakpoints.')
parser.add_argument('filename', help='MUMmer BTAB file')
parser.add_argument('-c','--chromosome',help='Target chromosome.', required=True)
parser.add_argument('-g','--gaps',help='Allowed gaps between contig pairs. Default=1', default=1)
parser.add_argument('-s','--score',help='Score cutoff. Default=1', default=1)
args = parser.parse_args()

tabFile = args.filename
gapLimit = args.gaps
SCORE_CUTTOFF = args.score
target_scaffold = args.chromosome

ALLOW_INTERNAL = True



table = tableTypeConvert([line for line in csv.reader(open(tabFile),delimiter='\t')], BTAB_TYPES)

#contigs = getColumn(table,0)

pairJump = 1 + gapLimit

maxLines = len(table) - pairJump

LEN_TABLE =  len(table)

#alignDict = alignCoverage(table)
#print "alignDict finished"

# Generates a dictionary of paired alignment blocks
pairDict = {}
for pJ in range(pairJump):
    pairDict = createPairDict(pairDict, table, maxLines, pJ+1)
    
# Iterates over the dictionary generated above and outputs alignment pairs that passes filtering
# and aligns in the pattern consistent with two inversion breakpoints.
for key, value in pairDict.iteritems():
    invPair = inversePair(key)

    if value[0]:
        if invPair in pairDict:
            vout = ""
            prevgaps = -1
            for j in value[1]:
                if j[2] != target_scaffold:
                    continue
                elif j[-1] < SCORE_CUTTOFF:
                    continue
                elif j[1] > prevgaps and prevgaps >= 0:
                    continue

                first_break = j[3]

                prevgaps = j[1]

                vout += printInvList(j, table)
            
            iout = ""
            prevgaps = -1
            for j in pairDict[invPair][1]:
                if j[2] != target_scaffold:
                    continue
                elif j[-1] < SCORE_CUTTOFF:
                    continue
                elif j[1] > prevgaps and prevgaps >= 0:
                    continue

                second_break = j[3]

                prevgaps = j[1]

                iout += printInvList(j, table)
            
            
            if vout and iout:
                breakdist = first_break-second_break
                
                if first_break < second_break:
                    b1 = first_break
                    b2 = second_break
                else:
                    b2 = first_break
                    b1 = second_break
                
                print tabFile + "\t" + target_scaffold +"\t" + key + "\t" + str(abs(breakdist)) + "\t" + str(b1) + "\t" + str(b2)
            pairDict[invPair][0] = False

